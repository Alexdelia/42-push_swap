Idea 1:

while (!sorted || b != NULL)
{
	p = (all value in a / size(a));

	if a > p
		ra (a put to back)
	else
		pb (a to b)
	
	need to have:
	b:
	 /
	/

	a:
	  \
	   \
	
	BiB = bigger b (b > best_found && b < ub)
	SmA = smaller a (actual < best_found && a > ua)
	while (b != BiB || a != SmA)
	{
		if (b != BiB && a != SmA)
			rrr
		else if (b != BiB)
			rrb
		else if (a != SmA)
			rra
	}

	// here SmA bot
	// and  BiB bot

	// this an old update, I fix and find opti

	rr until next small and big come to top
	
	- first put top b on a:

	if number of rr > size(b) / 2
		rb until last biggest b top
	else
		rrb until last biggest b top
	pb
		
	- second put top a on b

	if number of rr > size(a) / 2
		ra until last smallest a top
	else
		rra until last smallest a top
	pa

	rr until SmA bot and BiB bot (will happens at the same time)

	redo until b sorted and a reverse sorted

	then pa until !b

	all sorted
}

Idea 3:

if (size(a) == 3)

ABC : sorted
BAC : sa ABC : sorted
CBA : sa BCA : rra ABC : sorted
ACB : rra BAC : sa ABC : sorted
BCA : rra ABC : sorted
CAB : ra ABC : sorted
